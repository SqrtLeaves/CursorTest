/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MathVariableExpander
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_view = require("@codemirror/view");
var MathVariableExpander = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.variables = /* @__PURE__ */ new Map();
    this.parseTimeout = null;
  }
  async onload() {
    console.log("Loading Math Variable Expander plugin");
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.parseVariables();
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", (editor) => {
        if (this.parseTimeout)
          clearTimeout(this.parseTimeout);
        this.parseTimeout = setTimeout(() => {
          this.parseVariables();
        }, 500);
      })
    );
    this.registerEditorExtension(this.createExtension());
    this.parseVariables();
  }
  onunload() {
    console.log("Unloading Math Variable Expander plugin");
    this.variables.clear();
  }
  parseVariables() {
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView)
      return;
    const content = activeView.editor.getValue();
    const newVariables = /* @__PURE__ */ new Map();
    const variablePattern = /\$!!(\w+)\s*=\s*\[([^\]]+)\]\$/g;
    let match;
    while ((match = variablePattern.exec(content)) !== null) {
      const variableName = match[1];
      const expression = match[2].trim();
      newVariables.set(variableName, expression);
    }
    const changed = newVariables.size !== this.variables.size || Array.from(newVariables.entries()).some(
      ([name, expr]) => this.variables.get(name) !== expr
    );
    if (changed) {
      this.variables = newVariables;
      console.log(
        `Parsed ${this.variables.size} math variable(s):`,
        Array.from(this.variables.keys()).join(", ")
      );
    }
  }
  createExtension() {
    return import_view.keymap.of([
      {
        key: "Space",
        run: (view) => {
          return this.handleSpaceKey(view);
        }
      }
    ]);
  }
  isInMathBlock(view, pos) {
    const doc = view.state.doc;
    const beforeText = doc.sliceString(0, pos);
    const beforeDisplayMath = beforeText.match(/\$\$/g);
    if (beforeDisplayMath && beforeDisplayMath.length > 0) {
      if (beforeDisplayMath.length % 2 === 1) {
        return true;
      }
    }
    const withoutDisplayMath = beforeText.replace(/\$\$[\s\S]*?\$\$/g, "");
    const dollarCount = (withoutDisplayMath.match(/\$/g) || []).length;
    return dollarCount % 2 === 1;
  }
  handleSpaceKey(view) {
    const state = view.state;
    const selection = state.selection.main;
    const pos = selection.head;
    if (!this.isInMathBlock(view, pos)) {
      return false;
    }
    const doc = state.doc;
    const line = doc.lineAt(pos);
    const lineText = line.text;
    const posInLine = pos - line.from;
    const beforeCursor = lineText.substring(0, posInLine);
    const match = beforeCursor.match(/!!(\w+)$/);
    if (!match) {
      return false;
    }
    const variableName = match[1];
    const expression = this.variables.get(variableName);
    if (!expression) {
      return false;
    }
    const startPos = pos - match[0].length;
    const endPos = pos;
    view.dispatch({
      changes: {
        from: startPos,
        to: endPos,
        insert: expression
      },
      selection: {
        anchor: startPos + expression.length,
        head: startPos + expression.length
      }
    });
    return true;
  }
};
